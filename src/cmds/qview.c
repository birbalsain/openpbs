/*
 * Copyright (C) 1994-2019 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */
/**
 * @file	qview.c
 * @brief
 * 	qview - (PBS) send requiest to batch job
 *
 * @author	birbal ram sain
 * Altair Engineering Inc.
 */
#include <pbs_config.h> /* the master config generated by configure */
#include <pbs_version.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/utsname.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <signal.h>
#include <termios.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#define MAX 1024
#define SA struct sockaddr
#ifndef WIN32
#include <sys/un.h>
#include <syslog.h>
#endif

#include "pbs_ifl.h"
#include "cmds.h"
#include "libpbs.h"
#include "net_connect.h"
#include "dis.h"
#include "port_forwarding.h"
int sockfd1, connfd1;
int connect1;
void sigint_handler(int sig)
{
  /*do something*/
  /*send(connfd1, hello, sizeof(hello), 0);*/
  shutdown(sockfd1,SHUT_RDWR);
  shutdown(connfd1,SHUT_RDWR);
  close(sockfd1);
}

void qview_read(int sockfd)
{
  char buff[MAX];
   // infinite loop for chat
  for (;;) {
      bzero(buff, MAX);
          // read the message from client and copy it in buffer
      if(read(sockfd, buff, (sizeof(buff)-1))>0){
          // read the message from client and copy it in buffer
          buff[MAX-1]='\0';
          printf("%s", buff);
      } else {
          printf("mom socket closed");
          break;
      }
  }

}

int
main(int argc, char **argv, char **envp) /* qview */
{
  int c;
  int reqinfo;
  int errflg=0;
  int any_failed=0;
  char job_id[PBS_MAXCLTJOBID];       /* from the command line */
  char job_id_out[PBS_MAXCLTJOBID];
  char server_out[MAXSERVERNAME];
  char rmt_server[MAXSERVERNAME];

    /* for socket */
  int len1;
  struct sockaddr_in servaddr1, cli1;
  int Port;

    /* for ip address */
  char hostbuffer[256];
  char *IPadd;
  struct hostent *host_entry;
  /*int hostname; */

    // To retrieve hostname
  (void) gethostname(hostbuffer, sizeof(hostbuffer));

    // To retrieve host information
  host_entry = gethostbyname(hostbuffer);

    // To convert an Internet network
    // address into ASCII string
  IPadd = inet_ntoa(*((struct in_addr*) host_entry->h_addr_list[0]));


  #define GETOPT_ARGS "eo"

  /*test for real deal or just version and exit*/

  PRINT_VERSION_AND_EXIT(argc, argv);

  #ifdef WIN32
    if (winsock_init()) {
     return 1;
    }
  #endif

    reqinfo= 0;

    while ((c = getopt(argc, argv, GETOPT_ARGS)) != EOF)
      switch (c) {
        case 'e':
          reqinfo |= joberr;
          break;
        case 'o':
          reqinfo |= jobout;
          break;
        default :
          errflg++;
      }
    if (reqinfo == 0) reqinfo = joberr;	/* default */
    if (errflg || ((optind) >= argc) || (optind<2) || (argc >3)){
      static char usage[]=
      "usage: qview [-o [-e] job_identifier...\n";
      static char usag2[]=
      "       qview --version\n";
      fprintf(stderr, "%s", usage);
      fprintf(stderr, "%s", usag2);
      exit(0);
    }
    /*perform needed security library initializations (including none)*/

    if (CS_client_init() != CS_SUCCESS) {
      fprintf(stderr, "qview: unable to initialize security library.\n");
      exit(0);
    }

    int stat=0;
    int located = FALSE;

    strcpy(job_id, argv[optind]);
    if (get_server(job_id, job_id_out, server_out)) {
        fprintf(stderr, "qview: illegally formed job identifier: %s\n", job_id);
        any_failed = 1;
        exit(0);
    }
  // socket create and verification 
    sockfd1 = socket(AF_INET, SOCK_STREAM,0);
    if (sockfd1 == -1) {
      printf("socket creation failed...\n");
      exit(0);
    }
    bzero(&servaddr1, sizeof(servaddr1));
  
    // assign IP, PORT
    servaddr1.sin_family = AF_INET;
    servaddr1.sin_addr.s_addr = inet_addr(IPadd);
    servaddr1.sin_port = 0;
  
    // Binding newly created socket to given IP and verification
    if ((bind(sockfd1, (SA*) &servaddr1, sizeof(servaddr1))) != 0) {
      printf("socket bind failed...\n");
      exit(0);
    }
    signal(SIGINT, sigint_handler);
    pbs_socklen_t namelen = sizeof(servaddr1);
    if (getsockname(sockfd1, (SA*) &servaddr1,
      &namelen) < 0) {
      printf("qview: unable to get port number");
      exit(0);
    }
    Port = ntohs(servaddr1.sin_port);
    // Now server is ready to listen and verification
    if ((listen(sockfd1, 1)) != 0) {
      printf("Listen failed...\n");
      exit(0);
    }
    pid_t pid;
    int status;
    pid=fork();
    if (pid==0){
    // Accept the data packet from client and verification
      len1 = sizeof(cli1); 
      connfd1 = accept(sockfd1, (SA*)&cli1, &len1);
      if (connfd1 < 0) { 
          printf("server acccept failed...\n");
          exit(3);
      } 
      (void) qview_read(connfd1); 

         // After chatting close the socket
      close(sockfd1);
      exit(0);
    }
    else if(pid>0){
  cnt:
      connect1 = cnt2server(server_out);
      if (connect1 <= 0) {
        fprintf(stderr, "qview: cannot connect1 to server %s (errno=%d)\n",
        pbs_server, pbs_errno);
        any_failed = pbs_errno;
        close(sockfd1);
        kill(pid, SIGTERM);
        kill(pid, SIGKILL);
        waitpid(pid, &status, 0);
      }

      stat = pbs_reqinfo(connect1, job_id_out, reqinfo, Port, IPadd, NULL);
      if (stat && (pbs_errno != PBSE_UNKJOBID)) {
        prt_job_err("qview", connect1, job_id_out);
        any_failed = pbs_errno;
        close(sockfd1);
        kill(pid, SIGTERM);
        kill(pid, SIGKILL);
        waitpid(pid, &status, 0);
      } else if (stat && (pbs_errno == PBSE_UNKJOBID) && !located) {
        located = TRUE;
        if (locate_job(job_id_out, server_out, rmt_server)) {
          pbs_disconnect(connect1);
          strcpy(server_out, rmt_server);
          goto cnt;
        }
        prt_job_err("qview", connect1, job_id_out);
        any_failed = pbs_errno;
        close(sockfd1);
        kill(pid, SIGTERM);
        kill(pid, SIGKILL);
        waitpid(pid, &status, 0);
      }

      (void) wait(&status);
      pbs_disconnect(connect1);
       /*cleanup security library initializations before exiting*/

      CS_close_app();
      exit(any_failed);
    }
}
